# 面经

## Node 知识点总结
 - 浏览器工作原理，
 - 熟悉HTTP协议，
 - 熟悉设计模式

### 事件驱动
更改到连接服务器的方式，每个连接发射（emit）一个在Node.js引擎进程中运行的事件（Event)，放进事件队列当中，而不是为每个连接生成一个新的OS ！！！线程！！！（并未其分配一些配套内存）。

### 非阻塞
Node.js非阻塞I/O事件会创建一个线程去执行，然后主线程会继续往下执行，因此，profile的动作触发一个I/O事件，马上就会去执行拿timeline的动作，两个动作并行执行，加入各需要1s，那么总的时间就是1s。它们的I/O操作执行完成后，会发射一个事件，profile和timeline，事件代理接收后继续往下执行后面的逻辑，这就是Node.js非阻塞I/O的特点。

Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。

### Steam 
在处理大容量文件的时候，可以用流进行处理，每次处理一部分数据块，而不是一次性在内存中缓冲整个文件。就好比一根水管，慢慢从水池中取水。水管的体积取决于传入流构造函数的highWaterMark选项。
* 可读流（Readable）。
* 可写流（Writable）。
* 双工流，可读又可写流（Duplex）。
* 转换流，在读写过程中修改数据的流（Transform）。

### new Buffer()
	每次请求会导致开启一个500mb的新空间，会导致内存崩溃
	这个会读取未初始化的内存数据，会导致内存泄漏
	用这个前一定要类型检查 要不然会导致DDOS攻击


### 协议
	#### http https
	#### TCP 如何处理丢包、乱序，以及拥塞控制是如何做的
		弱网会导致丢包，心跳确认如果不返回，将会断开，重新进行请求 又要经历三次握手，这是导致tcp慢的主要原因
		当接收方收到乱序的数据段时，会立刻发送三个连续的 ACK 触发发送方的重传。
		拥塞控制在丢包的时候会降低吞吐量
		高铁等场景会不停丢包，然后会不停的重试，接下来会导致涌赛会变大
### 架构
	设计模式 分布式。MFC
### 存储
	mysql nosql
### 缓存
	缓存可以出现在 浏览器 网络转发（linux）服务器 数据库
	缓存是一个数据模型对象
	命中率=返回正确结果数/请求缓存次数
### 安全
	CORS、CSRF、XSS、HSTS、CSP 

### 数据结构

	list vs array 
		内存上 list是分散的 array是连续的
		array 加个元素 所有的元素要往后移动一步
		list加个元素 改变节点指针即可
		array在内存管理方面通常会存入缓存（因为是连续的所以是 局部性原理）
		list 不会放入缓存 list最大的作用就是动态扩容

	栈 
		是一个漏桶 先放进先出来，作用是操作系统建立某个进程或者线程是 来为这个线程建立存储区域的 fifo

	堆
		是 桶 后进先出 主要操作时 pop 和push

	栈 vs 队列
		删除元素位置不同，栈在表尾删除，队列在表头删除

	树

### 排序算法


### async原理
 V8 的性能和稳定性优化  
        使用高效的steam
        修改新生代的内存上限 128mb  node --max-semi-space-size=128 app.js
        限制本地缓存对象的大小，比如使用 FIFO、TTL 之类的机制来清理对象中的缓存 
对系统整体性能进行评估，解决内存瓶颈
第三方库 clinic 使用 clinic bubbleprof 来查看性能问题
熟悉监控和运维体系

### setTimeOut(),setImmediate()
	两者都是主线程结束后立即执行，setImmediate（）先执行
	使用 setImmediate() 相对于setTimeout() 的主要优势是，如果setImmediate()是在 I/O 周期内被调度的，那它将会在其中任何的定时器之前执行，跟这里存在多少个定时器无关

### setInterval()

### process.nextTick()

### array list 

Js 原型 prototype 也可以用__proto__来访问一个对象的原型
	apple1.__proto__ === Apple.prototype

### 原型继承
	对于类 A 和类 B，如果满足 A.prototype.__proto__ === B.prototype，那么 A 原型继承 B

static
只能通过类名来调用，不能被实例对象调用
static方法也可以被继承

### array的方法
	指定某个位置的元素
		arr[1] = ['b'];
	push 向数组后面添加一个元素
 	unshift 向数组前面插入一个元素
	delete 伪删除（数组length不变）
		length 赋值删除
			var arr = [0, 1, 2];
			arr.length = 1;// arr = [0]
	pop 删除数组的第一个元素
	shift 删除数组的最后一个元素
	splice  实现数组的复杂修改
		返回值
			由被删除元素组成的数组
		start
			修改数组的开始位置
		deleteCount
			要移除数组元素的个数，可选，不指定则从start删除至数组末尾
	slice 提取数组元素
		var arr = [0, 1, 2, 3];
		arr.slice(0, 1);// [0]

	reduce 累加数组元素

### string的方法
	charAt
	slice
		摘取一个字符串的区域 返回一个新的字符
	substring()
	
		返回在字符串中指定两个下标之间的字符
	.indexOf()
		指定字符串的值
	trimStart()
		去除空格


### 深拷贝 
JSON.parse( JSON.stringify(arr) );
### 浅拷贝
slice、concat 返回一个新数组的特性来实现拷贝。

### 6种数据类型
Undefined,Null,布尔值,字符串,数值,对象

### Es6 
 Symbol 是独一无二的

模板字符串
```
let message = `
	<ul>
		<li>1</li>
		<li>2</li>
	</ul>
`;

call apply bind 
```


制定 function的 this 方向 
其中 bind 需要最后加 （） 是个函数 

cookie 
4k 默认浏览器关闭 消失 也可以设置失效时间
localstorge 
5mb 默认永久保存 

array 
Slice 

Class 
 Static 这个是静态方法 可以在继承中调用 可以在本身里调用 但是就是不能在 new 实例化里调用

Class 的私有域 前面加上# 定义的话 就是一个私有的域 或者 是值 或者是 私有方法

EventEmitter, Stream, FS, Net和全局对象

### Node 的全局对象 
process, console, Buffer

### Node 的事件循环
process.nextTick >> setImmidate >> setTimeout/SetInterval

### EventEmitter
事件订阅 订阅用 on

两个node程序之间怎样交互?

: 用fork嘛，上面讲过了．原理是子程序用process.on, process.send，父程序里用child.on,child.send进行交互.

node是异步非阻塞的，这对高并发非常有效．可是我们还有其它一些常用需求，比如和操作系统shell命令交互，调用可执行文件，创建子进程进行阻塞式访问或高CPU计算等，child-process就是为满足这些需求而生的．child-process顾名思义，就是把node阻塞的工作交给子进程去做

Node 单线程缺点 高密集性计算 cpu性的 不行

Node 时间循环 导致的 他并发很高

### python 
链表 
元组 不可变序列的链表 
字典 建值对 
集合 无序可变序列，但是值必须是唯一

Bdd 工具 cucumber

### K8s 如果访问pod 
	创建一个service 用 selector 来访问 pod 
    ① v1 是 Service 的 apiVersion。
    ② 指明当前资源的类型为 Service。
    ③ Service 的名字为 httpd-svc。
    ④ selector 指明挑选那些 label 为 run: httpd 的 Pod 作为 Service 的后端。
    ⑤ 将 Service 的 8080 端口映射到 Pod 的 80 端口，使用 TCP 协议。

Docker 网络类型 用默认的 bridge 

回测 框架 backtrader 

FMZ平台的回测 也可以用于回测 一般用模拟级回测


### 事物的四大特性(ACID)介绍一下?
原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 死锁
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
如果业务处理不好可以用分布式事务锁或者使用乐观锁

### 大表数据查询，怎么优化？
    优化shema、sql语句+索引；
    第二加缓存，memcached, redis；
    主从复制，读写分离；
    垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统
    水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表

### 主键使用自增ID还是UUID？
    推荐使用自增ID，不要使用UUID。
    因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，
		也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，
		如果主键索引是自增ID，那么只需要不断向后排列即可，
		如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。
    总之，在数据量大一些的情况下，用自增主键性能会好一些。
    关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。

### MySQL主从复制解决的问题？
    数据分布：随意开始或停止复制，并在不同地理位置分布数据备份
    负载均衡：降低单个服务器的压力
    高可用和故障切换：帮助应用程序避免单点失败
    升级测试：可以用更高版本的MySQL作为从库

### 按照锁的粒度分数据库锁有哪些？
    行级锁:行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    表级锁: 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
    页级锁:页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

### 联合索引是什么？为什么需要注意联合索引中的顺序？
    MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

### 什么是聚簇索引？何时使用聚簇索引与非聚簇索引？
    聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
    非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。


B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。
如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引

### OSI七层和TCP/IP四层的关系
    OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。
    OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。
    OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。

    #### 应用层
        HTTP、TFTP, FTP, NFS, WAIS、SMTP
        Telnet, Rlogin, SNMP, Gopher
        SMTP, DNS
    #### 传输层
        TCP, UDP
    #### 网络层
        IP, ICMP, ARP, RARP, AKP, UUCP
    #### 数据链路层
        FDDI, Ethernet, Arpanet, PDN, SLIP, PPP
        IEEE 802.1A, IEEE 802.2到IEEE 802.11

### 浏览器在使用HTTPS传输数据的流程是什么？
	首先客户端通过URL访问服务器建立SSL连接。
	服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
	客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
	客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
	服务器利用自己的私钥解密出会话密钥。
	服务器利用会话密钥加密与客户端之间的通信。


String（字符串）
List（列表）
Hash（字典）
Set（集合）
Sorted Set（有序集合）

redis 批量处理
持久化策略

### API 优化
乐观锁 悲观锁
如何判断索引是否工作
	explain 函数来查看索引命中情况
哪些不建议用索引
	重复性差的不用
	频繁更新的不用
	。。。
索引类型
	1.普通索引
	2.唯一索引
	3.主键索引
	4.组合索引
	5.全文索引

服务通信 
	 监听者模式

	分布式 缓存同步 怎么做
	如果本地缓存存在这个key 直接返回
	如果不存在 则到分布式缓存里找
	如果分布式缓存里存在 则返回他的值并且把key 新增到本地
	如果都不存在 从数据库找 然后更新

原型链的继承

this 执行上下文

垃圾回收 算法
	- 新生代 老生代

pg 和 mongo的对比

express 和 http 模块


电话面试
1. 自我介绍 英文，会问过去的项目经验
2. 分布式锁
	处理同一个东西的时候要上锁，在限定时间内锁只能用锁的线程进行释放
4. springboot springcloud
5. CICD
6. docker有没有使用过
为什么换工作
Java 8 的新特性
left join 与 right join的区别
	返回左表和右边关联字段记录
	返回右表和左表所有字段记录
了解的设计模式
	- 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，
	但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。

	- 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，
	代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。

	- 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。

	- 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，
	然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。

分布式事务，如何处理
	两段提交 都ready 进行操作 一起成功 一起回滚 但是会遇到阻塞等各种意外
	tcc原则

接口 幂等
	用在接口上就可以理解为：同一个接口，多次发出同一个请求，必须保证操作只执行一次
hashmap底层实现，如何扩容
Stream.map 出来是什么
Lamda表达式
如何实现基于方法的接口
hashcode and equals，usage
Threadpool：key params，how it works
JVM runtime data area
MySQL composite index
一个有限空间进行大数据量排序的方案问题
	外排序
		进行等量划分后 取每分进行排序先 然后 再进行归并

算法
    就是问了个等价关系的查询
    并查集的算法 
		帮派争斗的比喻 帮主出来战斗 递归来查 合并的话找代表节点也就是父节点进行并归
    找最优解的算法
	··遗传算法
架构就是问电商的架构 
微服务间通信 
	监听者模式
超卖怎么解决
	乐观锁
		所有资源都可以带着版本号去更新 只有版本号符合才难更新成功 充分利用cpu

### 微服务容错
服务隔离 
	集群中 a调用b，b调用c， 假设b服务大量堆积，那么会导致a没办法继续有效果的调用a，那么我们就需要对各个服务进行隔离
	- 隔离又分 线程池隔离，信号量隔离， 开销大，异步
	- 线程池隔离是 假设a调用b占用10个线程，那么就只占用十个线程，这样就不会影响到另外的服务， 开销小，不能异步，切换性能高
	- 信号量隔离 如果拿不到信号，那么就进行隔离

服务降级 
	- 两个服务a 和 b， a的业务满足度大于b，但是a不能用了，改为调用b
服务熔断 
	- 两个服务a 和 b， a不能用了，接下来完全忽略a，只是用b
服务熔断回复
	- 两个服务a 和 b， a不能用了，接下来完全忽略a，只是用b， 突然a又可以了，开心的用回a
服务限流

限速
	- 按连接数进行限速, 初级阶段不用
	- 按请求速率进行限速，主要选择方向
	
### 日志
	- access log， errlog 这两个是 网关的log
	- 系统日志 是node service的日志

### 系统日志分级
	- info 重要的事件的记录 类似于: jack created one record
	- debug 这个是给开发者的
	- warning 不会中断程序，就像是用户输错
	- err 错误捕捉 就像 拉不到隔壁服务的数据
	
